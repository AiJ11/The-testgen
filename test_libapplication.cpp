#include <iostream>
#include <cassert>
#include <memory>
#include <fstream>
#include "jsCodeGenerator/jsCodeGen.h"
#include "ast.hpp"
#include "algo.hpp"
#include "library_apispec_examples/Entry.hpp"
#include "./symbol_table.hpp"
//#include "parser.hpp"

// Conditional include for symbolic engine
#ifdef USE_SYMBOLIC_ENGINE
#include "SymbolicEngine/TestGenDriver.hpp"
#endif

using namespace std;

void test_manual_examples(){
    std::cout << "=== TESTING TESTGEN ALGORITHM ===" << std::endl;
    
    // Generate specification and TestGen program (unchanged)
    auto res = Entry::start();
    auto spec = std::move(res.first);
    auto symtable = res.second;
    
    PrintVisitor visitor;
    std::cout << "\n=== SPECIFICATION ===" << std::endl;
    spec->accept(visitor);
    
    // Generate TestGen program
    Program testGenProgram = convert(spec.get(), symtable);
    std::cout << "\n=== TESTGEN PROGRAM ===" << std::endl;
    std::cout << "Generated program with " << testGenProgram.statements.size() << " statements" << std::endl;
    testGenProgram.accept(visitor);
    
#ifdef USE_SYMBOLIC_ENGINE
    // Optional symbolic execution when enabled
    std::cout << "\n=== TESTGEN SYMBOLIC EXECUTION ===" << std::endl;
    
    auto result = TestGenDriver::generateConcreteTestCase(testGenProgram, true);
    
    if (result.satisfiable) {
        std::cout << "\n SUCCESS: Generated concrete test case!" << std::endl;
        
        std::cout << "\n=== CONCRETE TEST INPUTS ===" << std::endl;
        for (const auto& [varName, value] : result.concreteValues) {
            if (!value.empty()) {
                std::cout << "  " << varName << " = \"" << value << "\"" << std::endl;
            }
        }
        
        std::cout << "\n=== READY-TO-USE TEST VALUES ===" << std::endl;
        std::cout << "We can now use these concrete values to test our API:" << std::endl;
        for (const auto& [varName, value] : result.concreteValues) {
            if (!value.empty() && (varName.find("token") != std::string::npos || 
                                  varName.find("studentId") != std::string::npos ||
                                  varName.find("username") != std::string::npos ||
                                  varName.find("password") != std::string::npos)) {
                std::cout << "  Use " << varName << " = \"" << value << "\" in API call" << std::endl;
            }
        }
        
        // Write results to files for further processing
        std::ofstream smtFile("testgen_output.smt2");
        smtFile << result.smtContent;
        smtFile.close();
        
        std::ofstream resultsFile("concrete_test_values.txt");
        resultsFile << "Concrete Test Case Generated by TestGen Symbolic Engine\n";
        resultsFile << "================================================\n\n";
        for (const auto& [varName, value] : result.concreteValues) {
            if (!value.empty()) {
                resultsFile << varName << " = " << value << "\n";
            }
        }
        resultsFile.close();
        
        std::cout << "\n=== FILES WRITTEN ===" << std::endl;
        std::cout << "- testgen_output.smt2 (SMT constraints)" << std::endl;
        std::cout << "- concrete_test_values.txt (test values)" << std::endl;
        
    } else {
        std::cout << "\n FAILED: Could not generate concrete test case" << std::endl;
        std::cout << "Error: " << result.errorMessage << std::endl;
        
        if (!result.smtContent.empty()) {
            std::cout << "\n=== Generated SMT (for debugging) ===" << std::endl;
            std::cout << result.smtContent.substr(0, 500) << std::endl;
            if (result.smtContent.length() > 500) {
                std::cout << "... (truncated)" << std::endl;
            }
        }
        
        if (!result.z3Output.empty()) {
            std::cout << "\n=== Z3 Output (for debugging) ===" << std::endl;
            std::cout << result.z3Output << std::endl;
        }
    }
#else
    // When symbolic engine is not enabled
    std::cout << "\n=== SYMBOLIC ENGINE NOT AVAILABLE ===" << std::endl;
    std::cout << "To enable symbolic execution with concrete test case generation:" << std::endl;
    std::cout << "  make symbolic     # Build with symbolic engine" << std::endl;
    std::cout << "  ./testgen_symbolic" << std::endl;
#endif
    
    // Generate ExpoSE code (always available)
    std::cout << "\n=== JAVASCRIPT GENERATION ===" << std::endl;
    ExpoSECodeGenerator ecg;
    std::string code = ecg.generateCode(testGenProgram);
    std::cout << code << std::endl;
    
    // Clean up
    for (auto* child : symtable.children) {
        delete child;
    }
}

int main(int argc, char** argv) {
    (void)argc; (void)argv;
    
    std::cout << "TestGen Algorithm" << std::endl;
    std::cout << "=================" << std::endl;
    
    try {
        test_manual_examples();
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
